% !TeX root = ../main.tex
\chapter{面向场景的评估系统实现}

在前文完成系统总体架构设计与核心模块功能分析的基础上，
本章将介绍面向场景的静态分析工具评估系统的具体实现过程。

本章基于场景知识库的设计，
围绕“场景生成—场景管理—评估计算”这一核心工程流程，
详细阐述系统关键功能模块的实现方法与工程细节，
首先介绍场景知识库的工程实现，
然后重点说明在引入大语言模型后，
系统如何在不确定性条件下尽量保证结果的质量；
随后说明场景资产在系统中的管理、去重与分类实现；
接着重点描述评估流程的自动化实现方式；
最后从工程角度分析系统在工具替换与功能扩展方面的实现特性。
基于本文的系统设计和功能目的，
python语言以其优秀的可读性、丰富的库支持和强大的社区支持，
成为了本文系统实现的主要语言。

\section{场景知识库的实现}

本节从工程实现角度出发，
说明场景知识库在系统中的数据组织方式，
以及该设计如何支撑后续的场景生成、检索、去重与评估流程实现。
本节首先介绍场景实体的核心字段，
再介绍场景空间的信息如何由字段数据承载，
最后介绍如何通过自然语言将结构化信息和代码结合到一起。

\subsection{场景实体的核心字段}

根据本文设计的ER图\ref{fig:ER图},
场景实体是整个知识库的核心单元，
一个场景实体需要记录代码、
空间信息、
属于哪个缺陷等信息，
表\ref{tab:场景实体核心字段}逐一介绍了场景实体的核心字段。

\begin{table}
	\centering
	\caption{场景实体核心字段}
	\label{tab:场景实体核心字段}
	\begin{tabular}{ccp{9cm}}
		\hline
		字段                   & 格式     & 含义                       \\
		\hline
		description          & string & 代码内容的自然语言描述              \\
		description\_vector  & list   & 用于向量检索的向量数据              \\
		good                 & dict   & good代码内容,键值为file:content \\
		bad                  & dict   & bad代码内容,键值为file:content  \\
		weakness             & int    & 所属的缺陷CWE ID              \\
		program\_span        & int    & 场景空间的 $P$ 维度:程序跨度        \\
		semantic\_complexity & int    & 场景空间的 $S$ 维度:语义建模复杂度     \\
		path\_complexity     & int    & 场景空间的 $C$ 维度:路径结构复杂度     \\
		path\_depth          & int    & 场景空间的 $L$ 维度:路径深度与状态空间控制 \\
		reachability         & int    & 场景空间的 $R$ 维度:有无不可达路径     \\
		\hline
	\end{tabular}
\end{table}

% 字段和表的解释
其中description、good、bad三者是场景基础信息，
其他的是场景空间信息和检测结果的记录。
在知识库中除了场景实体作为核心表，
还需要记录覆盖和应该覆盖的关系，
分别记录运行之后规则和场景的覆盖结果、
规则和缺陷之间应该覆盖的真实值。
场景知识库的完整数据模型见图\ref{fig:详细ER图}。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{详细ER图.png}
	\caption{详细ER图}
	\label{fig:详细ER图}
\end{figure}

为支持基于自然语言描述的模糊检索与基于结构化字段的精确过滤，
场景知识库选用 ElasticSearch（ES） 作为统一的存储与检索后端。
并通过容器化方式部署以保证实验环境的一致性与可复现性。
具体部署见章节\ref{ch:实验与分析}。

% ES 的数据模型去除 关系
在 Elasticsearch 中，
本文定制化的方式表达一对多关系和多对多关系。
对于一对多关系，
相关信息直接以内嵌字段形式存储于主文档中；
对于多对多关系，
则根据其在系统中的语义角色进行区分处理：
与评估结果直接相关的覆盖关系被存在coverage\_index中，
以支持高效的统计与聚合分析，
并且每次运行检查都添加新的覆盖关系，
在需要的时候，
可以根据观察到工具规则的能力进化；
而规则与缺陷之间的应覆盖关系，
属于相对固定的数据，
不会经常变化，
所以作为规则语义的一部分存储于规则元数据中。
该设计避免了跨索引 join 操作，
又能够利用ES的高性能检索能力，
提供准确的覆盖关系分析，
符合 Elasticsearch 面向分析型查询的使用特性。

\subsection{场景空间信息的数据承载方式}
\label{sec:场景空间信息的数据承载方式}

% 维度的可选性
场景在空间中的信息并不是连续的，
如章节\ref{sec:场景空间}所述，
也并不是每个场景都有所有的维度，
维度是根据缺陷语义而不同的。
在具体实现中，
场景维度被统一建模为可选字段，
系统仅对存在有效取值的维度参与后续的分类与评估计算。

% 维度的字段表达方式
根据本文所涉及的刻度，
场景利用不同字段中的枚举或数字来维护维度信息。
数字使用前缀编码的方式，
0代表最简单的情况，
也可以代表该维度是平凡的；
第一个非零数字表示刻度，
后面的数字表示刻度内部的子维度，
维度信息刻画如表\ref{tab:场景空间信息字段含义},
这些字段体现的是本文目前的刻度设计，
前缀编码的方式也适合后续拓展。

\begin{table}
	\centering
	\caption{场景空间信息字段含义}
	\label{tab:场景空间信息字段含义}
	\begin{tabular}{lp{9cm}}
		\hline
		字段       & 含义                \\
		\hline
		weakness & 所属的缺陷CWE ID       \\
		\hline

		\makecell[l]{
		Program\_Span                \\
		程序跨度                         \\
		}
		         & \makecell[l]{
		0：单函数内部；                     \\
		1：上下文无关跨函数；                  \\
		2：上下文敏感跨函数；                  \\
		3x：跨文件，后缀 x 表示跨文件层数；         \\
		9：全程序（本维度上限）                 \\
		}
		\\
		\hline

		\makecell[l]{
		Semantic\_Complexity         \\
		语义建模复杂度                      \\
		}
		         & \makecell[l]{
		0：无语义；                       \\
		1：混淆正则匹配的语义，需要理解语法；          \\
		2：混淆if、while等\tc~语法，需要理解控制流； \\
		3：混淆控制流的语义，需要理解状态；           \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Complexity             \\
		路径结构复杂度                      \\
		}
		         & \makecell[l]{
		0：顺序结构；                      \\
		11：在if路径中；                   \\
		12：在else路径中；                 \\
		21：在while的路径中；               \\
		22：在for的路径中；                 \\
		23：在while的break路径中；          \\
		24：在for的break路径中；            \\
		3：在if和while/for复合的路径中；       \\
		9：在无限复杂的路径中（该维度的上限）          \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Depth                  \\
		路径深度与状态空间控制                  \\
		}
		         & \makecell[l]{
		0：不需要控制路径深度；                 \\
		1：if/else需要合并；               \\
		2：switch中多个case需要合并；         \\
		3：有无限增长的路径，工具规则需要能够兜底；       \\
		4x：在非平凡循环之外的if语句中，           \\
		后缀x表示非平凡循环层数，                \\
		需要有一定的展开能力；                  \\
		5：在大循环的末端，                   \\
		需要使用widen技术划分循环；             \\
		}
		\\
		\hline

		\makecell[l]{
		Reachability                 \\
		有无不可达路径                      \\
		}
		         & \makecell[l]{
		0：无不可达路径；                    \\
		1：有不可达路径；                    \\
		}
		\\
		\hline
	\end{tabular}
\end{table}

举例来说，
表达式(\ref{eq:场景1})描述了一个场景的空间信息，

\begin{equation}
	\mathcal{p} = \langle
	D = 476,
	P = 1,
	S = 3,
	C = 12,
	L = 45,
	R = 0
	\rangle
	\label{eq:场景1}
\end{equation}

它是比较复杂的场景，
除了维度R，
其他的维度都是非平凡的，
场景1的描述如下：

\textbf{
	场景符合以下特征:
	属于缺陷\texttt{CWE-476:NULL\_Pointer\_Dereference},
	其含义是The product dereferences a pointer that it expects to be valid but is NULL.
	发生在如下的条件中：
	程序跨度：数据的源 和 缺陷的触发 在上下文无关的跨函数之间；
	语义建模复杂度：缺陷触发条件混淆控制流的语义，发生在某种特定状态下；
	路径结构复杂度：缺陷发生在else分支中；
	路径深度：发生在非平凡循环外的分支中，
	且循环深度为5；
	有无不可达路径：没有不可达路径。
}

具体代码内容见附录\ref{lst:场景1实际代码}，
它完整的体现了上述场景内容。

\subsection{自然语言描述构建信息桥梁}

% 自然语言作为桥梁的原因
场景需要被检索，
但是代码检索是另一个课题，
不是本文的重点。
本文有两类重要的知识需要互相检索，
一是代码文本，
二是场景的空间信息。
在正向梳理的时候，
需要从一个空间信息检索出相关的代码，
并且需要模糊检索，
以应对原有场景不足的情况；
在对场景进行空间定位的时候，
需要根据代码内容获取到空间信息。
在这两种情况下，
通过自然语言作为二者的桥梁非常合适。
自然语言的检索是非常成熟的，
已经有非常方便的检索工具，
并且支持模糊检索，
代码和场景空间信息与自然语言的转换也比较直接，
因此本文选择使用自然语言作为桥梁，
图\ref{fig:自然语言作为检索桥梁}展示了其中的理由。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{自然语言作为检索桥梁.png}
	\caption{自然语言作为检索桥梁}
	\label{fig:自然语言作为检索桥梁}
\end{figure}

% 对自然语言桥梁作用的解释
实际上章节\ref{sec:场景空间信息的数据承载方式}中
对表达式(\ref{eq:场景1})的含义解释，
正是通过自然语言的方式连接了该场景空间和代码\ref{lst:场景1实际代码}。
如果单独看场景空间信息表达式(\ref{eq:场景1})和代码\ref{lst:场景1实际代码}，
不能感到其中的联系，
但是使用章节\ref{sec:场景空间信息的数据承载方式}中的描述就清晰易懂了，
这正是场景实体中description字段的作用，
它实现了场景空间信息和代码内容之间的互相理解。

基于上述实现方式，
系统中的每一个场景实例都有着结构化的场景空间信息，
并用自然语言描述作为检索与生成的中介表示。
在系统实现中，
自然语言并非评估对象本身，
而是作为连接场景空间信息与代码实例的中间表示，
用于支撑检索、生成与定位等工程流程。
该表示方式为后续的场景生成机制、
场景去重与分类以及评估流程自动化提供了统一的数据基础。

\section{场景生成机制实现}

本节介绍场景生成机制的实现，
这是场景工厂模块的主要功能。
在上述场景知识库实现的基础上，
场景生成模块仅依赖场景实体中 description 字段及其关联的空间信息字段，
不操作评估与覆盖相关数据。

\subsection{以描述为核心构建提示词}

根据章节\ref{sec:系统总体架构}和章节\ref{sec:场景工厂模块}的设计，
场景工厂会接收到生成请求，
请求分为两种情况，
一是正向梳理，
二是被动补充。

% 创建描述
正向梳理时的请求数据即维度数据，
当用户需要补充空间中某个位置的场景，
就把该位置信息作为请求数据发出，
场景工厂模块使用表\ref{tab:场景空间信息字段含义}的含义，
使用字典映射的方式创建相应的描述；
被动补充时请求数据由测试人员创建，
用自然语言把实际软件产品的缺陷问题描述出来，
尽量按照章节\ref{sec:场景空间信息的数据承载方式}中
对表达式(\ref{eq:场景1})的描述格式来用自然语言描述，
这是一种理想情况，
如果没有按照这个格式,
只是描述了问题发生的路径，
也可以进行生成，
只是需要更多的人工审核。

% 检索
利用LLM进行场景生成需要拼接提示词，
其中的参考内容由检索获得，
根据一个自然语言描述检索出最相关的已有描述。
本文在具体实现中采用两种检索方式，
BM25和向量检索，
他们的能力和优势如章节\ref{sec:测试集拓展和生成式人工智能}所述。
为了适应大规模数据，
本文在具体实现中首先使用向量检索的语义理解能力，
根据Embedding模型将描述转换为向量，
并利用ES的description\_vector字段进行向量检索，
检索出语义相似的场景描述；
然后使用BM25的精准搜索能力，
用来捕捉场景空间维度信息等关键词；
这种粗排加精排的可以兼顾检索速度和检索准确性。
这正是图\ref{fig:复合检索RAG}展示的检索方式的实现。

% 提示词和生成
获得了检索到的参考内容之后，
需要将参考内容拼接成提示词，
本文使用了模板的方式，
将参考内容拼接成提示词。
提示词模板如\ref{lst:场景生成提示词}所示，
其中关键字段的解释如表\ref{tab:场景生成提示词含义}所示，
使用时将这些字段替换成实际的场景信息。
本文创建了通用的LLM对话接口，
可以配置不同的LLM作为对话的对象，
让功能和LLM对话解耦。
将替换完成的提示词交给LLM对话接口，
就可以完成一次待校验的场景生成。

\begin{table}
	\centering
	\caption{场景生成提示词含义}
	\label{tab:场景生成提示词含义}
	\begin{tabular}{cp{9cm}}
		\hline
		字段          & 含义                     \\
		\hline
		description & 目标场景的自然语言描述            \\
		result      & 生成的结果字典格式参考，让结果可以被解析   \\
		reference   & 检索到的参考结果，是一组描述和生成结果的对应 \\
		last\_err   & 上一次的结果和不通过责任链的错误反馈     \\
		\hline
	\end{tabular}
\end{table}

\subsection{RAG生成结果的工程约束}

为保证生成场景能够被后续管理与评估流程正确处理，
系统在场景生成阶段引入责任链式的校验机制，
用于对生成结果施加一组最小工程约束。
RAG生成的结果以文本形式返回，
系统通过解析result字段还原具体代码文件，
并将其作为责任链的输入对象。
责任链中的每一个节点均实现统一的pass接口，
输入为一组场景代码文件，
输出为是否满足该约束的判定结果。

% 仅介绍编译校验
在系统设计中，责任链机制支持配置多个校验节点，
以满足不同场景在语义、环境或工程约束上的需求。
在本文的实验与实现中，
为保证实验的可复现性与环境一致性，
仅选取与具体分析工具和企业环境无关的校验节点进行实现与验证。
其中，编译校验作为所有场景必须满足的最小工程约束，
在系统中被实现为一个独立的责任链节点。
该节点用于验证生成的代码在不执行的情况下，
能够完成预处理、编译、汇编与链接过程，
从而保证生成场景在工程层面是自洽且可分析的。

% 编译校验的实现
在编译校验的节点中，
它首先识别目标目录下的代码文件类型，
并根据文件类型选择对应的编译器，
包括gcc、g++与clang++等。
系统对代码进行编译与链接但不执行，
一旦编译过程出现错误，
则收集编译器返回的错误信息作为校验失败原因。

% 编译校验的反馈
当编译校验未通过时，
系统将对应的错误信息写入last\_err字段，
并在下一轮生成时作为反馈加入提示词中。
为避免多轮错误信息的累积造成提示混淆，
系统仅保留最近一次校验失败的反馈内容。
同时，
为防止生成过程陷入无效循环，
系统为场景生成流程设置最大迭代次数，
超过该次数后终止生成过程。

上述功能经过汇总，
实现类图如图\ref{fig:场景工厂详细类图}所示。

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{场景工厂详细类图.png}
	\caption{场景工厂详细类图}
	\label{fig:场景工厂详细类图}
\end{figure}

这里对其中比较关键的检索类 Retriever 进行简单介绍，
它的功能是根据场景描述检索出知识库中与场景描述最相关的文档，
场景工厂和场景资产管理模块都需要使用到该类。
Retriever直接依赖ES，
使用标准第三方库进行数据获取，
基于此实现了retrieve\_bm25函数和retrieve\_embedding函数，
retrieve函数调用这两者，
并返回一个包含多个文档的列表。

实现了详细类图中的功能，
场景生成流程在工程层面形成了“生成—校验—反馈—终止”的闭环，
其整体流程与图\ref{fig:场景生成活动图}所示一致。

\section{场景资产管理模块关键能力实现}

在完成场景生成与工程约束校验之后，
系统需要对已生成的场景进行统一管理，
以支撑后续的评估流程调度、覆盖度统计与结果分析。
为此，本文在系统中实现了场景去重、分类基础的管理机制，
以保证场景集合在规模扩展过程中的可控性与可维护性。

本模块的详细类图如图\ref{fig:场景资产管理详细类图}所示，
其中两个重要功能为场景去重与分类。

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{场景资产管理详细类图.png}
	\caption{场景资产管理详细类图}
	\label{fig:场景资产管理详细类图}
\end{figure}

\subsection{基于场景空间的分类实现}

对于被动补充的场景，
系统通过分析其代码结构，
将其定位到最匹配的场景空间中。
每一个场景在生成完成并通过校验后，
都会被映射到该空间中的唯一坐标点。
在实现层面，
系统使用ES的字段为每一个场景维护一份结构化的空间描述信息，
其维度来源于章节\ref{sec:分析缺陷范围边界}所定义的分析能力边界划分，
字段表示来自于表\ref{tab:场景空间信息字段含义}所定义的数据含义。
本文创建了标准的提示词，
系统使用LLM的判断能力，
将分类标准设置在提示词文档中，
让LLM拥有了这些字段含义的理解，
知道如何根据代码结构进行分类。
分类功能也依赖Retrieve类的检索能力，
以过往场景描述类似的场景作为检索文档库，
检索出“场景描述+代码 ： 场景空间位置”的键值对作为参考。
LLM的回答也被规范化，
本功能通过对字段的解析获得到场景空间位置，
并更新场景知识库中的信息。

\subsection{场景等价性与去重策略}

随着场景生成过程的自动化与迭代执行，
系统可能在不同生成轮次中产生语义相近甚至完全等价的场景。
若不加以控制，重复场景将显著增加评估成本，
并对覆盖度统计结果产生干扰。

在去重功能的工程实践中，
本文不尝试对“程序语义完全等价”这一问题进行形式化判定，
而是从评估任务的实际需求出发，
将场景等价性解释为：
在给定分析工具与评估维度下，
对覆盖结果不产生实质性差异的场景集合。
系统采用两个层级的判断方案：
首先选择场景的空间信息完全一致的场景作为去重候选集，
然后基于场景描述与代码结构的相似度进行进一步判断。

在具体实现中，
系统将去重候选集作为检索文档库，
将所选场景的描述作为查询，
使用检索功能对文档库进行排序，
选择最相似的场景进入LLM判断环节。
本文创建了用于去重的提示词，
同样使用LLM的理解能力，
将查询和最相似的场景进行比较，
让LLM判断在给定分析工具与评估维度下，
他们是否在评估意义上等价。
如果是，
则将所选场景标记为重复场景，
经过人工确认后从知识库中删除；
否则不对所选场景进行任何操作。

该策略在保证去重效果的同时，
避免了复杂程序分析带来的额外开销，
符合系统对效率与可扩展性的工程要求。

\subsection{提供测试集、写测试结果}

作为场景管理的全部功能承担者，
本模块还实现了提供测试集、写测试结果的功能。

一方面，
集成化运行平台会发出获取测试集的请求，
本模块接收请求后，
获取所需的规则，
根据知识库中的rule\_index中的 should\_cover\_weakness字段获取对应的缺陷集合，
再从scene\_index中获取对应的场景集合,
作为该规则对应的测试集返回给集成化运行平台。

另一方面，
集成化平台经过运行检查、解析运行结果后，
会发出运行完成的消息，
本系统接收到运行完成消息后，
会执行两个步骤，
首先主动从集成化平台获取运行结果，
即扁平化的测试场景和规则的覆盖关系，
以及规则告警内容，
系统将这些覆盖关系更新到场景知识库中的coverage\_index中，
供计算模块计算评估指标使用；
其次就是指标计算模块进行自动化评估，
章节\ref{sec:评估流程自动化实现}对此进行了详细介绍。

本节介绍了场景资产管理模块的主要功能，
并详细说明了其在场景分类、去重与测试集管理等功能的具体实现。

\section{评估流程自动化实现}
\label{sec:评估流程自动化实现}

在完成场景管理与组织之后，
系统需要对大量场景执行分析工具并采集评估结果。
为降低人工干预成本并保证评估流程的一致性，
本文实现了评估流程的自动化执行机制，
其类图如图\ref{fig:工具指标计算类图}所示。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{工具指标计算类图.png}
	\caption{工具指标计算类图}
	\label{fig:工具指标计算类图}
\end{figure}

\subsection{占比类评估指标计算}

占比类评估指标自动化计算是本文系统的核心功能之一。
该计算的关键在于将表\ref{tab:静态分析检查得到的数据}中的各数据进行统计，

场景知识库的coverage\_index是根据时间增量记录的，
所以在检索的时候，
对于rule\_id、rule\_version和scene\_id都相同的记录，
以最新的时间戳为准，
只有后续需要计算历史更新的时候，
才对历史检查记录进行计算。

根据图\ref{fig:工具-规则-缺陷集}，
对于表\ref{tab:静态分析检查得到的数据}中的各个数据计算方法如下，
在coverage\_index中过滤目标为rule的最新覆盖记录，
将其中覆盖bad场景的列表记为$L\_bad$；
将其中覆盖good场景的列表记为$L\_good$,
如果有多个告警，
则$L\_good$是重复计数的；
将其中scene\_id相同且存在于$L\_bad$但不存在于$L\_good$的场景列表记为$L\_dis$；
将目标rule的should\_cover\_weakness集合记为$S$。

则TP（正报）等于$L\_bad$中缺陷类型属于$S$的场景数量，
即告警了的应告警的场景数;
FN（漏报）等于$S$中的场景数量减去TP，
即应报但没报的数量；
FP（误报）等于$L\_bad$中缺陷类型不属于$S$的场景数量加上$L\_good$，
即告警了的不应告警的场景数；
TN代表安全，
在指标计算中并不使用；
另外，
章节\ref{sec:评估指标}提到的 Discrimination 等于$L\_dis$中缺陷类型属于$S$的场景数量，
即区分了目标缺陷的正确代码和错误代码的数量，
获取了这些数据之后即可根据公式(\ref{eq:Precision})、
(\ref{eq:Recall})、(\ref{eq:F1})、(\ref{eq:Discrimination})计算
Precision、Recall、F1和Discrimination的值。
章节\ref{sec:评估指标}的公式(\ref{eq:CWE_Coverage})和(\ref{eq:Flow_Coverage})
虽然可以表达一定的工具能力，
但是本文将使用下文的能力边界评估指标代替他们。

\subsection{能力边界类评估指标计算}

归一化后的结果能够直观反映不同工具在同一场景空间维度下的覆盖表现，
并作为评估分析与结果展示的输入数据。
该过程为后续章节中的实验分析奠定了数据基础。

% \section{系统可扩展性与替换性分析}

% 在系统设计阶段，
% 本文即以支持多工具、多维度扩展为目标，
% 因此在实现过程中对模块之间的耦合关系进行了严格控制。

% \subsection{分析工具的替换机制}

% 系统通过工具适配层隔离具体分析工具的调用细节，
% 新工具的接入仅需实现统一的执行与结果解析接口，
% 无需修改场景管理与评估调度逻辑。
% 该机制保证了系统能够随着分析工具的演进持续扩展。

% \subsection{场景维度的扩展能力}

% 场景空间的维度定义采用配置化与结构化描述方式，
% 新增维度仅需在空间描述模型中进行声明，
% 即可被分类、统计与评估流程自动感知。
% 该设计避免了维度扩展对既有系统逻辑的破坏。

% \subsection{评估流程的模块解耦}

% 评估流程各阶段通过明确接口进行衔接，
% 场景管理、工具执行与指标计算模块相互独立。
% 这种模块解耦设计不仅提升了系统的可维护性，
% 也为后续功能增强与性能优化提供了良好基础。