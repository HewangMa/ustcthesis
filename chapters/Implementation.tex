% !TeX root = ../main.tex
\chapter{面向场景的评估系统实现}

在前文完成系统总体架构设计与核心模块功能分析的基础上，
本章将介绍面向场景的静态分析工具评估系统的具体实现过程。

本章基于场景知识库的设计，
围绕“场景生成—场景管理—评估计算”这一核心工程流程，
详细阐述系统关键功能模块的实现方法与工程细节，
首先介绍场景知识库的工程实现，
然后重点说明在引入大语言模型后，
系统如何在不确定性条件下尽量保证结果的质量；
随后说明场景资产在系统中的管理、去重与分类实现；
接着重点描述评估流程的自动化实现方式；
最后从工程角度分析系统在工具替换与功能扩展方面的实现特性。

\section{场景知识库的实现}

本节从工程实现角度出发，
说明场景知识库在系统中的数据组织方式，
以及该设计如何支撑后续的场景生成、检索、去重与评估流程实现。

本节首先介绍场景实体的核心字段，
再介绍场景空间的信息如何由字段数据承载，
最后介绍如何通过自然语言将结构化信息和代码结合到一起。

\subsection{场景实体的核心字段}

根据本文设计的ER图\ref{fig:ER图},
场景实体是整个知识库的核心单元，
一个场景实体需要记录代码、
空间信息、
属于哪个缺陷等信息，
表\ref{tab:场景实体核心字段}逐一介绍了场景实体的核心字段。

\begin{table}
	\centering
	\caption{场景实体核心字段}
	\label{tab:场景实体核心字段}
	\begin{tabular}{ccp{9cm}}
		\hline
		字段                   & 格式     & 含义                       \\
		\hline
		description          & string & 代码内容的自然语言描述              \\
		good                 & dict   & good代码内容,键值为file:content \\
		bad                  & dict   & bad代码内容,键值为file:content  \\
		weakness             & int    & 所属的缺陷CWE ID              \\
		Program\_Span        & int    & 场景空间的 $P$ 维度:程序跨度        \\
		Semantic\_Complexity & int    & 场景空间的 $S$ 维度:语义建模复杂度     \\
		Path\_Complexity     & int    & 场景空间的 $C$ 维度:路径结构复杂度     \\
		Path\_Depth          & int    & 场景空间的 $L$ 维度:路径深度与状态空间控制 \\
		Reachability         & int    & 场景空间的 $R$ 维度:有无不可达路径     \\
		\hline
	\end{tabular}
\end{table}

其中description、good、bad三者是场景基础信息，
其他的是场景空间信息。

在知识库中除了场景实体作为核心表，
还有覆盖表和应该覆盖表，
都是一个多对多的关系，
分别记录运行之后规则和场景的覆盖结果、
规则和缺陷之间应该覆盖的真实值。

为了满足系统大量的检索需求，
场景知识库使用ElasticSearch（ES）承载，
ES的检索功能包括向量检索和其他多种混合检索，
非常适合本文系统的需求。

\subsection{场景空间信息的数据承载方式}
\label{sec:场景空间信息的数据承载方式}

% 维度的可选性
场景在空间中的信息并不是连续的，
如章节\ref{sec:场景空间}所述，
也并不是每个场景都有所有的维度，
维度是根据缺陷语义而不同的。
在具体实现中，
场景维度被统一建模为可选字段，
系统仅对存在有效取值的维度参与后续的分类与评估计算。

% 维度的字段表达方式
根据本文所涉及的刻度，
场景利用不同字段中的枚举或数字来维护维度信息。
数字使用前缀编码的方式，
0代表最简单的情况，
也可以代表该维度是平凡的；
第一个非零数字表示刻度，
后面的数字表示刻度内部的子维度，
维度信息刻画如表\ref{tab:场景空间信息字段含义},
这些字段体现的是本文目前的刻度设计，
前缀编码的方式也适合后续拓展。

\begin{table}
	\centering
	\caption{场景空间信息字段含义}
	\label{tab:场景空间信息字段含义}
	\begin{tabular}{lp{9cm}}
		\hline
		字段       & 含义                \\
		\hline
		weakness & 所属的缺陷CWE ID       \\
		\hline

		\makecell[l]{
		Program\_Span                \\
		程序跨度                         \\
		}
		         & \makecell[l]{
		0：单函数内部；                     \\
		1：上下文无关跨函数；                  \\
		2：上下文敏感跨函数；                  \\
		3x：跨文件，后缀 x 表示跨文件层数；         \\
		9：全程序（本维度上限）                 \\
		}
		\\
		\hline

		\makecell[l]{
		Semantic\_Complexity         \\
		语义建模复杂度                      \\
		}
		         & \makecell[l]{
		0：无语义；                       \\
		1：混淆正则匹配的语义，需要理解语法；          \\
		2：混淆if、while等\tc~语法，需要理解控制流； \\
		3：混淆控制流的语义，需要理解状态；           \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Complexity             \\
		路径结构复杂度                      \\
		}
		         & \makecell[l]{
		0：顺序结构；                      \\
		11：在if路径中；                   \\
		12：在else路径中；                 \\
		21：在while的路径中；               \\
		22：在for的路径中；                 \\
		23：在while的break路径中；          \\
		24：在for的break路径中；            \\
		3：在if和while/for复合的路径中；       \\
		9：在无限复杂的路径中（该维度的上限）          \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Depth                  \\
		路径深度与状态空间控制                  \\
		}
		         & \makecell[l]{
		0：不需要控制路径深度；                 \\
		1：if/else需要合并；               \\
		2：switch中多个case需要合并；         \\
		3：有无限增长的路径，工具规则需要能够兜底；       \\
		4x：在非平凡循环之外的if语句中，           \\
		后缀x表示非平凡循环层数，                \\
		需要有一定的展开能力；                  \\
		5：在大循环的末端，                   \\
		需要使用widen技术划分循环；             \\
		}
		\\
		\hline

		\makecell[l]{
		Reachability                 \\
		有无不可达路径                      \\
		}
		         & \makecell[l]{
		0：无不可达路径；                    \\
		1：有不可达路径；                    \\
		}
		\\
		\hline
	\end{tabular}
\end{table}

举例来说，
表达式(\ref{eq:场景1})描述了一个场景的空间信息，

\begin{equation}
	\mathcal{p} = \langle
	D = 476,
	P = 1,
	S = 3,
	C = 12,
	L = 45,
	R = 0
	\rangle
	\label{eq:场景1}
\end{equation}

它是比较复杂的场景，
除了维度R，
其他的维度都是非平凡的，
场景1的描述如下：

\textbf{
	场景符合以下特征:
	属于缺陷\texttt{CWE-476:NULL\_Pointer\_Dereference},
	其含义是The product dereferences a pointer that it expects to be valid but is NULL.
	发生在如下的条件中：
	程序跨度：数据的源 和 缺陷的触发 在上下文无关的跨函数之间；
	语义建模复杂度：缺陷触发条件混淆控制流的语义，发生在某种特定状态下；
	路径结构复杂度：缺陷发生在else分支中；
	路径深度：发生在非平凡循环外的分支中，
	且循环深度为5；
	有无不可达路径：没有不可达路径。
}

具体代码见附录\ref{lst:场景1实际代码}

\subsection{自然语言描述与结构化信息的映射}

场景需要被检索，
但是代码检索是另一个课题，
不是本文的重点。

本文有两类重要的知识需要互相检索，
一是代码文本，
二是场景的空间信息。
在正向梳理的时候，
需要从一个空间信息检索出相关的代码，
并且需要模糊检索，
以应对原有场景不足的情况；
在对场景进行空间定位的时候，
需要根据代码内容获取到空间信息。
在这两种情况下，
通过自然语言作为二者的桥梁非常合适。
自然语言的检索是非常成熟的，
已经有非常方便的检索工具，
并且支持模糊检索，
代码和场景空间信息与自然语言的转换也比较直接，
因此本文选择使用自然语言作为桥梁，
图\ref{fig:自然语言作为检索桥梁}展示了其中的理由。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{自然语言作为检索桥梁.png}
	\caption{自然语言作为检索桥梁}
	\label{fig:自然语言作为检索桥梁}
\end{figure}

实际上章节\ref{sec:场景空间信息的数据承载方式}中
对表达式(\ref{eq:场景1})的含义解释，
正是通过自然语言的方式连接了该场景空间和代码\ref{lst:场景1实际代码}。
如果单独看场景空间信息表达式(\ref{eq:场景1})和代码\ref{lst:场景1实际代码}，
不能感到其中的联系，
但是使用章节\ref{sec:场景空间信息的数据承载方式}中的描述就清晰易懂了，
这正是场景实体中description字段的作用，
它实现了场景空间信息和代码内容之间的互相理解。

基于上述实现方式，
系统中的每一个场景实例都有着结构化的场景空间信息，
并用自然语言描述作为检索与生成的中介表示。
该表示方式为后续的场景生成机制、
场景去重与分类以及评估流程自动化提供了统一的数据基础。

\section{场景生成机制实现}

\subsection{以描述为核心构建提示词}

根据章节\ref{sec:系统总体架构}和章节\ref{sec:场景工厂模块}的设计，
场景工厂会接收到生成请求，
请求分为两种情况，
一是正向梳理，
二是被动补充。

正向梳理时的请求数据即维度数据，
当用户需要补充空间中某个位置的场景，
就把该位置信息作为请求数据发出，
场景工厂模块使用表\ref{tab:场景空间信息字段含义}的含义创建相应的描述；
被动补充时请求数据由测试人员创建，
用自然语言把实际软件产品的缺陷问题描述出来，
尽量按照章节\ref{sec:场景空间信息的数据承载方式}中
对表达式(\ref{eq:场景1})的描述格式来用自然语言描述，
这是一种理想情况，
如果没有按照这个格式,
只是描述了问题发生的路径，
也可以进行生成。

正如活动图\ref{fig:场景生成活动图}所介绍的，
利用LLM进行场景生成需要拼接提示词，
其中的参考内容由检索获得，
检索主要的功能就是根据一个自然语言描述检索出最相关的已有描述。
本文使用两种检索方式，
BM25和向量检索，
他们的能力和优势如章节\ref{sec:测试集拓展和生成式人工智能}所述。
本文首先需要使用向量检索的语义理解能力，
检索出语义相似的场景描述；
然后需要使用BM25的精准搜索能力，
用来捕捉场景空间维度信息等关键词；
由于两种检索方式的速度不同，
本文选择先用向量检索出大量相关内容，
然后再使用BM25检索关键词相关内容，
本文使用的正是图\ref{fig:复合检索RAG}展示的这种检索方式。

本文为场景生成设计了基础的提示词，
模板如\ref{lst:场景生成提示词}所示，
其中关键字段的解释如表\ref{tab:场景生成提示词}所示，
使用时将这些字段替换成实际的场景信息。
\begin{table}
	\centering
	\caption{场景生成提示词}
	\label{tab:场景生成提示词}
	\begin{tabular}{cp{9cm}}
		\hline
		字段          & 含义                     \\
		\hline
		description & 目标场景的自然语言描述            \\
		result      & 生成的结果字典格式参考，让结果可以被解析   \\
		reference   & 检索到的参考结果，是一组描述和生成结果的对应 \\
		last_err    & 上一次的结果和不通过责任链的错误反馈     \\
		\hline
	\end{tabular}
\end{table}

\subsection{LLM生成结果的工程约束}

RAG的能力使得LLM可以获取相关的知识，
但由于LLM生成内容有多种不确定性，
生成结果仍然不能满足场景的需求，
责任链校验因此必不可少。

本文为责任链创建了一个通用接口pass，
每个节点都需要实现这个接口，
输入是一段场景代码，
输出是一个布尔值。

责任链节点有很多个，
但有的依赖一些特殊的环境，
本文系统实际上使用了一些功能API来提供数据，
但是这属于企业内部功能，
无法提供实验结果。

这里仅介绍编译校验这一个责任链节点的实现。
场景的代码需要能够通过编译，
这是一个场景必须满足的需求。
为此需要有一个功能，
对一个目录下的代码进行编译链接。
具体来说，
是要完成若干代码文件的域处理、编译、汇编和连接但不运行，
如果中间报错，
则将报错信息返回。
场景工厂会将



% \section{场景去重、分类与管理实现}
% \subsection{场景等价性与去重策略}
% \subsection{基于场景空间的分类实现}
% \subsection{场景生命周期管理}

% \section{评估流程自动化实现}
% \subsection{评估流程总体调度机制}
% \subsection{工具执行与结果采集}
% \subsection{覆盖度指标计算与结果归一化}

% \section{系统可扩展性与替换性分析}
% \subsection{分析工具的替换机制}
% \subsection{场景维度的扩展能力}
% \subsection{评估流程的模块解耦}
