% !TeX root = ../main.tex
\chapter{面向场景的评估系统实现}

在前文完成系统总体架构设计与核心模块功能分析的基础上，
本章将介绍面向场景的静态分析工具评估系统的具体实现过程。

本章基于场景知识库的设计，
围绕“场景生成—场景管理—评估计算”这一核心工程流程，
详细阐述系统关键功能模块的实现方法与工程细节，
首先介绍场景知识库的工程实现，
然后重点说明在引入大语言模型后，
系统如何在不确定性条件下尽量保证结果的质量；
随后说明场景资产在系统中的管理、去重与分类实现；
接着重点描述评估流程的自动化实现方式；
最后从工程角度分析系统在工具替换与功能扩展方面的实现特性。
基于本文的系统设计和功能目的，
python语言以其优秀的可读性、丰富的库支持和强大的社区支持，
成为了本文系统实现的主要语言。

\section{场景知识库的实现}

本节从工程实现角度出发，
说明场景知识库在系统中的数据组织方式，
以及该设计如何支撑后续的场景生成、检索、去重与评估流程实现。
本节首先介绍场景实体的核心字段，
再介绍场景空间的信息如何由字段数据承载，
最后介绍如何通过自然语言将结构化信息和代码结合到一起。

\subsection{场景实体的核心字段}

根据本文设计的ER图\ref{fig:ER图},
场景实体是整个知识库的核心单元，
一个场景实体需要记录代码、
空间信息、
属于哪个缺陷等信息，
表\ref{tab:场景实体核心字段}逐一介绍了场景实体的核心字段。

\begin{table}
	\centering
	\caption{场景实体核心字段}
	\label{tab:场景实体核心字段}
	\begin{tabular}{ccp{9cm}}
		\hline
		字段                   & 格式     & 含义                       \\
		\hline
		description          & string & 代码内容的自然语言描述              \\
		description\_vector  & list   & 用于向量检索的向量数据              \\
		good                 & dict   & good代码内容,键值为file:content \\
		bad                  & dict   & bad代码内容,键值为file:content  \\
		weakness             & int    & 所属的缺陷CWE ID              \\
		program\_span        & int    & 场景空间的 $P$ 维度:程序跨度        \\
		semantic\_complexity & int    & 场景空间的 $S$ 维度:语义建模复杂度     \\
		path\_complexity     & int    & 场景空间的 $C$ 维度:路径结构复杂度     \\
		path\_depth          & int    & 场景空间的 $L$ 维度:路径深度与状态空间控制 \\
		reachability         & int    & 场景空间的 $R$ 维度:有无不可达路径     \\
		\hline
	\end{tabular}
\end{table}

% 字段和表的解释
其中description、good、bad三者是场景基础信息，
其他的是场景空间信息和检测结果的记录。
在知识库中除了场景实体作为核心表，
还需要记录覆盖和应该覆盖的关系，
分别记录运行之后规则和场景的覆盖结果、
规则和缺陷之间应该覆盖的真实值。
场景知识库的完整数据模型见图\ref{fig:详细ER图}。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{详细ER图.png}
	\caption{详细ER图}
	\label{fig:详细ER图}
\end{figure}

为支持基于自然语言描述的模糊检索与基于结构化字段的精确过滤，
场景知识库选用 ElasticSearch（ES） 作为统一的存储与检索后端。
并通过容器化方式部署以保证实验环境的一致性与可复现性。
具体部署见章节\ref{ch:实验与分析}。

% ES 的数据模型去除 关系
在 Elasticsearch 中，
本文定制化的方式表达一对多关系和多对多关系。
对于一对多关系，
相关信息直接以内嵌字段形式存储于主文档中；
对于多对多关系，
则根据其在系统中的语义角色进行区分处理：
与评估结果直接相关的覆盖关系被存在coverage\_index中，
以支持高效的统计与聚合分析，
并且每次运行检查都添加新的覆盖关系，
在需要的时候，
可以根据观察到工具规则的能力进化；
而规则与缺陷之间的应覆盖关系，
属于相对固定的数据，
不会经常变化，
所以作为规则语义的一部分存储于规则元数据中。
该设计避免了跨索引 join 操作，
又能够利用ES的高性能检索能力，
提供准确的覆盖关系分析，
符合 Elasticsearch 面向分析型查询的使用特性。

\subsection{场景空间信息的数据承载方式}
\label{sec:场景空间信息的数据承载方式}

% 维度的可选性
本系统使用数据承载场景空间信息，
场景维度被统一建模为可选字段，
系统仅对存在有效取值的维度参与后续的分类与评估计算。
根据本文所设计的刻度，
场景利用不同字段中的枚举或数字来维护维度信息。
数字使用前缀编码的方式，
0代表最简单的情况，
也可以代表该维度是平凡的；
第一个非零数字表示刻度，
后面的数字表示刻度内部的子维度，
维度信息刻画如表\ref{tab:场景空间信息字段含义},
这些字段体现的是本文目前的刻度设计，
前缀编码的方式也适合后续拓展。

\begin{table}
	\centering
	\caption{场景空间信息字段含义}
	\label{tab:场景空间信息字段含义}
	\begin{tabular}{lp{9cm}}
		\hline
		字段       & 含义                \\
		\hline
		weakness & 所属的缺陷CWE ID       \\
		\hline

		\makecell[l]{
		Program\_Span                \\
		程序跨度                         \\
		}
		         & \makecell[l]{
		0：单函数内部；                     \\
		1：上下文无关跨函数；                  \\
		2：上下文敏感跨函数；                  \\
		3x：跨文件，后缀 x 表示跨文件层数；         \\
		9：全程序（本维度上限）                 \\
		}
		\\
		\hline

		\makecell[l]{
		Semantic\_Complexity         \\
		语义建模复杂度                      \\
		}
		         & \makecell[l]{
		0：无语义；                       \\
		1：混淆正则匹配的语义，需要理解语法；          \\
		2：混淆if、while等\tc~语法，需要理解控制流； \\
		3：混淆控制流的语义，需要理解状态；           \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Complexity             \\
		路径结构复杂度                      \\
		}
		         & \makecell[l]{
		0：顺序结构；                      \\
		11：在if路径中；                   \\
		12：在else路径中；                 \\
		21：在while的路径中；               \\
		22：在for的路径中；                 \\
		23：在while的break路径中；          \\
		24：在for的break路径中；            \\
		3：在if和while/for复合的路径中；       \\
		9：在无限复杂的路径中（该维度的上限）          \\
		}
		\\
		\hline

		\makecell[l]{
		Path\_Depth                  \\
		路径深度与状态空间控制                  \\
		}
		         & \makecell[l]{
		0：不需要控制路径深度；                 \\
		1：if/else需要合并；               \\
		2：switch中多个case需要合并；         \\
		3：有无限增长的路径，工具规则需要能够兜底；       \\
		4x：在非平凡循环之外的if语句中，           \\
		后缀x表示非平凡循环层数，                \\
		需要有一定的展开能力；                  \\
		5：在大循环的末端，                   \\
		需要使用widen技术划分循环；             \\
		}
		\\
		\hline

		\makecell[l]{
		Reachability                 \\
		有无不可达路径                      \\
		}
		         & \makecell[l]{
		0：无不可达路径；                    \\
		1：有不可达路径；                    \\
		}
		\\
		\hline
	\end{tabular}
\end{table}

举例来说，
表达式(\ref{eq:场景1})描述了一个场景的空间信息，

\begin{equation}
	\mathcal{p} = \langle
	D = 476,
	P = 1,
	S = 3,
	C = 12,
	L = 45,
	R = 0
	\rangle
	\label{eq:场景1}
\end{equation}

它是比较复杂的场景，
除了维度R，
其他的维度都是非平凡的，
场景1的描述如下：

\textbf{
	场景符合以下特征:
	属于缺陷\texttt{CWE-476:NULL\_Pointer\_Dereference},
	其含义是The product dereferences a pointer that it expects to be valid but is NULL.
	发生在如下的条件中：
	程序跨度：数据的源 和 缺陷的触发 在上下文无关的跨函数之间；
	语义建模复杂度：缺陷触发条件混淆控制流的语义，发生在某种特定状态下；
	路径结构复杂度：缺陷发生在else分支中；
	路径深度：发生在非平凡循环外的分支中，
	且循环深度为5；
	有无不可达路径：没有不可达路径。
}

具体代码内容见附录\ref{lst:场景1实际代码}，
它完整的体现了上述场景内容。

该含义解释，
是根据表\ref{tab:场景空间信息字段含义}的含义固定映射而来，
系统中维护了这样的一个映射表，
实现了用自然语言连接该场景空间和代码\ref{lst:场景1实际代码}。
如果单独看场景空间信息表达式(\ref{eq:场景1})和代码\ref{lst:场景1实际代码}，
不能感到其中的联系，
但是使用上述描述就清晰易懂了，
这正是场景实体中description字段的作用，
它实现了场景空间信息和代码内容之间的互相理解。

基于上述实现方式，
系统中的每一个场景实例都有着结构化的场景空间信息，
并用自然语言描述作为检索与生成的中介表示。
在系统实现中，
自然语言并非评估对象本身，
而是作为连接场景空间信息与代码实例的中间表示，
用于支撑检索、生成与定位等工程流程。
该表示方式为后续的场景生成机制、
场景去重与分类以及评估流程自动化提供了统一的数据基础。

\section{场景生成机制实现}

本节介绍场景生成机制的实现，
这是场景工厂模块的主要功能。
在上述场景知识库实现的基础上，
场景生成模块仅依赖场景实体中 description 字段及其关联的空间信息字段，
不操作评估与覆盖相关数据。

\subsection{以描述为核心构建提示词}

根据章节\ref{sec:系统总体架构}和章节\ref{sec:场景工厂模块}的设计，
场景工厂会接收到生成请求，
请求分为两种情况，
一是正向梳理，
二是被动补充。

% 创建描述
正向梳理时的请求数据即维度数据，
当用户需要补充空间中某个位置的场景，
就把该位置信息作为请求数据发出，
场景工厂模块使用表\ref{tab:场景空间信息字段含义}的含义，
使用字典映射的方式创建相应的描述；
被动补充时请求数据由测试人员创建，
用自然语言把实际软件产品的缺陷问题描述出来，
尽量按照章节\ref{sec:场景空间信息的数据承载方式}中
对表达式(\ref{eq:场景1})的描述格式来用自然语言描述，
并清晰的描述问题发生的路径。

% 检索
利用LLM进行场景生成需要拼接提示词，
其中的参考内容由检索获得，
根据一个自然语言描述检索出最相关的已有描述。
本文在具体实现中采用两种检索方式，
BM25和向量检索，
他们的能力和优势如章节\ref{sec:测试集拓展和生成式人工智能}所述。
为了适应大规模数据，
本文在具体实现中首先使用向量检索的语义理解能力，
根据Embedding模型将描述转换为向量，
并利用ES的description\_vector字段进行向量检索，
检索出语义相似的场景描述；
然后使用BM25的精准搜索能力，
用来捕捉场景空间维度信息等关键词；
这种粗排加精排的可以兼顾检索速度和检索准确性。
这正是图\ref{fig:复合检索RAG}展示的检索方式的实现。

% 提示词和生成
获得了检索到的参考内容之后，
需要将参考内容拼接成提示词，
本文使用了模板的方式，
将参考内容拼接成提示词。
提示词模板如\ref{lst:场景生成提示词}所示，
其中关键字段的解释如表\ref{tab:场景生成提示词含义}所示，
使用时将这些字段替换成实际的场景信息。
本文创建了通用的LLM对话接口，
可以配置不同的LLM作为对话的对象，
让功能和LLM对话解耦。
将替换完成的提示词交给LLM对话接口，
就可以完成一次待校验的场景生成。

\begin{table}
	\centering
	\caption{场景生成提示词含义}
	\label{tab:场景生成提示词含义}
	\begin{tabular}{cp{9cm}}
		\hline
		字段          & 含义                     \\
		\hline
		description & 目标场景的自然语言描述            \\
		result      & 生成的结果字典格式参考，让结果可以被解析   \\
		reference   & 检索到的参考结果，是一组描述和生成结果的对应 \\
		last\_err   & 上一次的结果和不通过责任链的错误反馈     \\
		\hline
	\end{tabular}
\end{table}

\subsection{RAG生成结果的工程约束}

为保证生成场景能够被后续管理与评估流程正确处理，
系统在场景生成阶段引入责任链式的校验机制，
用于对生成结果施加一组最小工程约束。
RAG生成的结果以文本形式返回，
系统通过解析result字段还原具体代码文件，
并将其作为责任链的输入对象。
责任链中的每一个节点均实现统一的pass接口，
输入为一组场景代码文件，
输出为是否满足该约束的判定结果。

% 仅介绍编译校验
在系统设计中，责任链机制支持配置多个校验节点，
以满足不同场景在语义、环境或工程约束上的需求。
在本文的实验与实现中，
为保证实验的可复现性与环境一致性，
仅选取与具体分析工具和企业环境无关的校验节点进行实现与验证。
其中，编译校验作为所有场景必须满足的最小工程约束，
在系统中被实现为一个独立的责任链节点。
该节点用于验证生成的代码在不执行的情况下，
能够完成预处理、编译、汇编与链接过程，
从而保证生成场景在工程层面是自洽且可分析的。

% 编译校验的实现
在编译校验的节点中，
它首先识别目标目录下的代码文件类型，
并根据文件类型选择对应的编译器，
包括gcc、g++与clang++等。
系统对代码进行编译与链接但不执行，
一旦编译过程出现错误，
则收集编译器返回的错误信息作为校验失败原因。

% 编译校验的反馈
当编译校验未通过时，
系统将对应的错误信息写入last\_err字段，
并在下一轮生成时作为反馈加入提示词中。
为避免多轮错误信息的累积造成提示混淆，
系统仅保留最近一次校验失败的反馈内容。
同时，
为防止生成过程陷入无效循环，
系统为场景生成流程设置最大迭代次数，
超过该次数后终止生成过程。

上述功能经过汇总，
实现类图如图\ref{fig:场景工厂详细类图}所示。

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{场景工厂详细类图.png}
	\caption{场景工厂详细类图}
	\label{fig:场景工厂详细类图}
\end{figure}

这里对其中比较关键的检索类 Retriever 进行着重介绍，
它的功能是根据场景描述检索出知识库中与场景描述最相关的文档，
场景工厂和场景资产管理模块都需要使用到该类。
Retriever直接依赖ES，
使用标准第三方库进行数据获取，
基于此实现了retrieve\_bm25函数和retrieve\_embedding函数，
retrieve函数调用这两者，
并返回一个包含多个文档的列表。

实现了详细类图中的功能，
场景生成流程在工程层面形成了“生成—校验—反馈—终止”的闭环，
其时序图如图\ref{fig:场景生成时序图}所示。

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{场景生成时序图.png}
	\caption{场景生成时序图}
	\label{fig:场景生成时序图}
\end{figure}

\section{场景资产管理模块关键能力实现}

在完成场景生成与工程约束校验之后，
系统需要对已生成的场景进行统一管理，
以支撑后续的评估流程调度、覆盖度统计与结果分析。
为此，本文在系统中实现了场景去重、分类基础的管理机制，
以保证场景集合在规模扩展过程中的可控性与可维护性。

本模块的详细类图如图\ref{fig:场景资产管理详细类图}所示，
其中两个重要功能为场景去重与分类。

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{场景资产管理详细类图.png}
	\caption{场景资产管理详细类图}
	\label{fig:场景资产管理详细类图}
\end{figure}

\subsection{基于场景空间的分类实现}

场景分类在两种情况下被使用。
一是冷启动的时候，
数据库里没有任何场景，
就需要将JTS的测试用例转化为本文系统中的带有空间信息的场景。
二是被动补充，
它本身不带有空间信息，
需要将其定位到唯一的一个坐标点上。

在进行场景的分类时，
系统通过分析代码结构，
使用ES的字段为每一个场景维护一份结构化的空间描述信息，
其维度来源于章节\ref{sec:分析缺陷范围边界}所定义的分析能力边界划分，
字段表示来自于表\ref{tab:场景空间信息字段含义}所定义的数据含义。
本文创建了标准的提示词，
系统使用LLM的判断能力，
将分类标准设置在提示词文档中，
让LLM拥有了这些字段含义的理解，
知道如何根据代码结构进行分类。
分类功能也依赖Retrieve类的检索能力，
以过往场景描述类似的场景作为检索文档库，
检索出“场景描述+代码 ： 场景空间位置”的键值对作为参考。
LLM的回答也被规范化，
本功能通过对字段的解析获得到场景空间位置，
并更新场景知识库中的信息。

\subsection{场景等价性与去重策略}

随着场景生成过程的自动化与迭代执行，
系统可能在不同生成轮次中产生语义相近甚至完全等价的场景。
若不加以控制，重复场景将显著增加评估成本，
并对覆盖度统计结果产生干扰。

在去重功能的工程实践中，
本文不尝试对“程序语义完全等价”这一问题进行形式化判定，
而是从评估任务的实际需求出发，
将场景等价性解释为：
在给定分析工具与评估维度下，
对覆盖结果不产生实质性差异的场景集合。
系统采用两个层级的判断方案：
首先选择场景的空间信息完全一致的场景作为去重候选集，
然后基于场景描述与代码结构的相似度进行进一步判断。

在具体实现中，
系统将去重候选集作为检索文档库，
将所选场景的描述作为查询，
使用检索功能对文档库进行排序，
选择最相似的场景进入LLM判断环节。
本文创建了用于去重的提示词，
同样使用LLM的理解能力，
将查询和最相似的场景进行比较，
让LLM判断在给定分析工具与评估维度下，
他们是否在评估意义上等价。
如果是，
则将所选场景标记为重复场景，
经过人工确认后从知识库中删除；
否则不对所选场景进行任何操作。

该策略在保证去重效果的同时，
避免了复杂程序分析带来的额外开销，
符合系统对效率与可扩展性的工程要求。

\subsection{提供测试集、写测试结果}

作为场景管理的全部功能承担者，
本模块还实现了提供测试集、写测试结果等功能。

一方面，
集成化运行平台会发出获取测试集的请求，
本模块接收请求后，
获取所需的规则，
根据知识库中的rule\_index中的 should\_cover\_weakness字段获取对应的缺陷集合，
再从scene\_index中获取对应的场景集合,
作为该规则对应的测试集返回给集成化运行平台。

另一方面，
集成化平台经过运行检查、解析运行结果后，
会发出运行完成的消息，
本系统接收到运行完成消息后，
会执行两个步骤，
首先主动从集成化平台获取运行结果，
即扁平化的测试场景和规则的覆盖关系，
以及规则告警内容，
系统将这些覆盖关系更新到场景知识库中的coverage\_index中，
供计算模块计算评估指标使用；
其次就是指标计算模块进行自动化评估，
章节\ref{sec:评估流程自动化实现}对此进行了详细介绍。

本模块还需要实现模拟集成化运行平台的功能，
需要能够对一些工具运行结果进行自动化解析，
将运行结果顺利写入知识库。

本节介绍了场景资产管理模块的主要功能，
并详细说明了其在场景分类、去重与测试集管理等功能的具体实现。

\section{评估流程自动化实现}
\label{sec:评估流程自动化实现}

在完成场景管理与组织之后，
系统需要对大量场景执行分析工具并采集评估结果。
为降低人工干预成本并保证评估流程的一致性，
本文实现了评估流程的自动化执行机制，
计算模块的功能只紧接着在场景管理模块写回运行结果之后执行的，
其时序图如图\ref{fig:指标计算时序图}所示,
其类图如图\ref{fig:工具指标计算类图}所示，
评估指标的计算流程如图\ref{fig:评估指标计算活动图}所示,
其中计算分为两部分介绍。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{指标计算时序图.png}
	\caption{指标计算时序图}
	\label{fig:指标计算时序图}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.7\textwidth]{工具指标计算类图.png}
	\caption{工具指标计算类图}
	\label{fig:工具指标计算类图}
\end{figure}

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth]{评估指标计算活动图.png}
	\caption{评估指标计算活动图}
	\label{fig:评估指标计算活动图}
\end{figure}

\subsection{占比类评估指标计算}

占比类评估指标自动化计算是本文系统的核心功能之一。
该计算的关键在于对表\ref{tab:静态分析检查得到的数据}中的以及相关数据进行统计，

场景知识库的coverage\_index是根据时间增量记录的，
所以在检索的时候，
对于rule\_id、rule\_version和scene\_id都相同的记录，
以最新的时间戳为准，
只有后续需要计算历史更新的时候，
才对历史检查记录进行计算。

根据图\ref{fig:工具-规则-缺陷集}，
对于表\ref{tab:静态分析检查得到的数据}中的各个数据计算方法如下，
首先将目标rule的should\_cover\_weakness集合记为$should\_set$；
再从coverage\_index中过滤目标为rule的最新覆盖记录，
将其中覆盖bad场景的列表记为$L\_bad$；
将其中覆盖good场景的列表记为$L\_good$,
如果有多个告警，
则$L\_good$是重复计数的；
将其中scene\_id相同且存在于$L\_bad$但不存在于$L\_good$的场景列表记为$L\_dis$；

则TP（正报）等于$L\_bad$中缺陷类型属于$should\_set$的场景数量，
即告警了的应告警的场景数;
FN（漏报）等于$should\_set$中的场景数量减去TP，
即应报但没报的数量；
FP（误报）等于$L\_bad$中缺陷类型不属于$should\_set$的场景数量加上$L\_good$，
即告警了的不应告警的场景数；
TN代表安全，
在指标计算中并不使用；
另外，
章节\ref{sec:评估指标}提到的 Discrimination 等于$L\_dis$中缺陷类型属于$should\_set$的场景数量，
即区分了目标缺陷的正确代码和错误代码的数量，
获取了这些数据之后即可根据公式(\ref{eq:Precision})、
(\ref{eq:Recall})、(\ref{eq:F1})、(\ref{eq:Discrimination})计算
Precision、Recall、F1和Discrimination的值。
章节\ref{sec:评估指标}的公式(\ref{eq:CWE_Coverage})和(\ref{eq:Flow_Coverage})
虽然可以表达一定的工具能力，
但是本文将使用下文的能力边界评估指标代替他们。

\subsection{能力边界类评估指标计算}

能力边界类评估指标自动化计算也是本文系统的核心功能之一。
基于章节\ref{sec:基于场景空间的测试结果解析}的介绍，
计算该类指标首先要获得某一维度的场景投影，
这通过ES的检索容易实现。
为了评估某一规则，
缺陷维度是默认被过滤的，
所以本文将$should\_set$视为全集，
选择一个维度，
只考虑该维度的场景投影，
本文设置了一个最少场景数的值 min\_evaluate\_cnt，
默认为3，
如果可用的评估场景低于该值，
则认为不足以提供可信的评估数据。
系统将$should\_set$中场景按照刻度划分，
将某一刻度的集合记为$mark\_set$，
则公式(\ref{eq:刻度覆盖率})中的$mark\_cnt$即为$cnt(mark\_set)$，
从coverage\_index中检索出该刻度中被目标规则覆盖的场景集合记为$covered\_set$，
则公式(\ref{eq:刻度覆盖率})中的$covered\_cnt$即为$cnt(covered\_set)$，
其中$cnt(x)$表示集合$x$中的元素数量。
由此可以计算出该刻度的mark\_coverage值。
对该维度来说，
获得了有效刻度的mark\_coverage值即可计算其方差，
衡量工具规则能力在该维度上的能力区分，
详细示例请见章节\ref{ch:实验与分析}。

本节的类图并不复杂，
详细介绍了两类评估指标的计算流程，
为后文实验和分析提供了实践支撑。

\section{系统实现章小结}

通过本章的实现说明，
可以看到本文所提出的面向场景的静态分析工具评估系统，
在工程上围绕“场景资产”构建了完整的生成、管理与评估闭环。

在场景生成阶段，
系统通过引入检索增强生成机制，
并结合责任链式校验流程，
在大语言模型存在生成不确定性的前提下，
尽量保证生成场景在语法与工程层面的可用性。

在场景管理与分类阶段，
基于场景空间的结构化表示，
系统能够对场景进行去重、分类与生命周期管理，
为评估流程提供稳定且可复用的场景资产基础。

在评估流程实现中，
系统通过自动化调度机制完成工具执行、结果采集与覆盖度指标计算，
避免了人工干预带来的不确定性与成本，
使评估结果具备可重复性。

从工程角度看，
本系统在场景表示、评估流程与工具调用层面均实现了解耦，
为后续分析工具的替换、评估维度的扩展以及评估策略的演进提供了实现基础。