% !TeX root = ../main.tex


% EvaluateModel
% → 定义问题本身，给出评估的数学/结构化对象

\chapter{场景化覆盖能力评估问题建模}

本章针对静态分析工具的场景化覆盖能力评估进行抽象化讨论，
旨在明确基于场景空间的静态分析工具能力评估方法应该如何设计。

从前文可以得出，
静态分析工具的评估重点在于测试集的设计和管理，
有了组织清晰的测试集，
实际测试的结果才可以清晰的展示静态分析工具的能力地图。
那么应该怎样设计测试集空间呢？
JTS给出了一些参考，
它使用Functional维度和FLow维度组织测试集，
这两个正交维度在每一个缺陷下都各自展开，
但是这样的维度仅能触及工具的一部分能力，
不能对其能力进行更细粒度的检查。

静态分析工具的检测能力不仅与自身原理和具体规则相关，
还与程序场景的结构特征高度相关。
为了对评估问题进行建模，
有必要从工具原理出发，
结合场景的代码结构，
抽象其在不同场景下的能力边界。
因此，本文对静态分析工具的检查能力进行细致分析，
并基于此设计场景空间维度。

本文的分析目标不以工具为单位，
而以工具的每一个规则为单位。
理由是工具不是单一能力，
工具的每个规则都对应着不同的分析策略和能力边界。
下文以规则一词指代静态分析工具的规则。
所以要强调的是，
要想对工具进行完整的评估，
必须以规则为粒度，
以分析范围为限制，
以能力边界为场景维度。

\section{静态分析工具的能力边界}
\label{sec:静态分析工具的能力边界}

本文把静态分析工具的能力分为两类，
一类是工具所能分析的范围，
具体来说，
包括静态分析工具规则所对应的缺陷范围，
和规则所能检查的工程作用域。
第二类是理解程序的能力范围，
分为语义建模深度、
路径敏感程度、
路径状态空间控制程度、
约束精化能力、
并发语义建模能力。

\subsection{分析缺陷范围边界}

工具的每一个规则都对应着若干缺陷。
每一个规则也都有着不同的能力要求，
例如分析空指针的规则需要对路径敏感，
而分析缓冲区的规则则需要对数值域敏感。
我们能够将每一个场景测例划分到唯一的缺陷中，
但不能把每一个规则划分到唯一的缺陷中，
规则对应的是一个缺陷子集，
该子集中的所有的测例都应该作为规则评估的测试对象。

例如Clang-tidy有一条规则，
名为\texttt{bugprone-unused-return-value},
功能是检查没有使用的函数返回值，
它对应着两个缺陷，分别是
\texttt{CWE-252:Unchecked\_Return\_Value}
未检查函数返回值，和
\texttt{CWE-253:Incorrect\_Check\_of\_Function\_Return\_Value}
检查函数返回值不当。

再例如Clang-tidy的一条规则，
名为\texttt{bugprone-empty-catch},
功能是检查并建议解决空的catch语句，
对应着两个缺陷，分别是
\texttt{CWE-390:Error\_Without\_Action}
产生了error但不执行任何动作，和
\texttt{CWE-391:Unchecked\_Error\_Condition}
忽略异常和其他错误条件。

以上两个规则在理想状态下，
都应该覆盖对应的缺陷集中的所有场景测例。
而相应的，
不划分在对应缺陷集中的任何场景测例都不需要被该规则负责，
要么它们由工具中的其他规则负责，
要么他们不在工具设计之初希望覆盖的范围之内。
图示\ref{fig:工具-规则-缺陷集}解释了这种关系。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{工具-规则-缺陷集.png}
	\caption{工具、规则、缺陷集之间的关系}
	\label{fig:工具-规则-缺陷集}
\end{figure}

\subsection{分析作用域边界}

要评估工具的能力，
工具规则所能分析的作用域边界也是重要的限制，
即工具规则能在什么工程范围内分析？

在\ref{sec:\tc~静态分析工具及其原理}章节中提到，
静态分析工具在跨函数、跨文件等情况下的分析能力参差不齐。
在典型的数据流分析中，
一个规则也许可以分析在一个函数内的关键数据，
但通过多种返回值传到函数外的数据就不能分析了；
一个规则也许可以分析跨函数数据，
但有上下文不同的跨函数数据就不能分析了；
一个规则也许可以分析上下文敏感的数据，
但跨文件传递的数据就不能分析了；
一个规则也许可以分析跨文件数据，
但通过文件读写、环境配置等情况的数据就不能分析了。

在非典型数据流分析的缺陷中，
也可以考虑规则的分析作用域。
比如前文提到的缺陷
\texttt{CWE-390:Error\_Without\_Action}
在error发生的位置，
也许程序确实没有处理动作，
但是该error被另一个文件的函数中的动作处理了，
那么对于分析域不同的工具规则来说，
也许一个规则会告警，
产生误报，
而另一个规则则不会告警，
其误报率则较低。
基于以上的分析和举例，
分析作用域边界应当作为一个规则能力的维度。

设定作用域为一个维度后，
应当考虑的是如何设计刻度。
刻度指的是规则在这个维度上的能力节点。
本文将分析作用域这个维度下的刻度设置如下：
\begin{enumerate}
	\item 单函数。
	      这是一个最小能力的规则应该能处理的分析范围。

	\item 上下文无关跨函数。
	      这个刻度下的规则可以处理经过函数传递的数据相关的分析，
	      但该刻度下存在一个子维度，即能够分析数据经过多少层函数传递。

	\item 上下文敏感跨函数。
	      这个刻度下的规则可以处理与上下文有关的跨函数数据分析，
	      例如全局变量、静态变量等。

	\item 跨文件。
	      这个刻度下的规则可以处理跨文件的数据分析，
	      例如一个文件中设计了某个功能，
	      通过一个接口传递给另一个文件中的函数。

	\item 全程序。
	      这个刻度下的规则可以分析全程序的数据流，
	      例如一个功能从配置文件中读取数据，
	      与它相关的数据流分析也可以做到。
\end{enumerate}

\subsection{语义建模深度边界}

在章节\ref{sec:\tc~静态分析工具及其原理}中提到，
不同工具在系统建模阶段对程序语义的抽象程度不同，
例如，对于Flawfinder工具来说，
它的建模方式是基于字符串的，
也就意味着它会被一些程序语义、语法、状态欺骗。
而Clang-tidy是基于编译构造的AST的，
它比理解字符串高一层，
可以理解程序的结构关系，
但是对变量、程序的状态所知不多。
为此，本文将语义建模深度作为一个工具能力的边界，
这个维度并不是简单的对工具系统建模属性的描述，
而是划分工具理解程序的能力边界，
是工具对程序进行抽象的能力。
该维度可以使用场景测例对能力边界进行探索和评估。

本文将该维度下的刻度划分设置如下。

\begin{enumerate}
	\item 无语义。
	      这个刻度下的工具规则不能理解任何程序语义，
	      仅从字符串和模式出发进行匹配分析。

	\item 语法级。
	      这个刻度下的工具规则可以理解if、while等语法，
	      了解程序的结构，
	      但对程序如何执行以及其中的变化和限制无法分析。

	\item 控制流级。
	      这个刻度下的工具规则可以理解程序的执行流程，
	      也就是理解了CFG控制流图。
	      可以分析一段程序有可能从哪些程序基本块进入，
	      到哪些基本块，
	      但不必区分不同执行路径。

	\item 状态级。
	      这个刻度下的规则不仅可以根据CFG理解程序的执行流程，
	      还能基于数据理解程序在某个时刻的状态，
	      也就是有数据流分析能力，
	      可以跟踪变量的取值。
\end{enumerate}


语义建模深度这个维度的划分粒度大约是工具级别的，
因为同一个工具的系统建模属性一般是一致的，
大部分规则都在同一种系统建模中执行检查。
在评估的时候也许这个维度的数据相对集中，
但不排除在这个维度上不同的规则有不同的表现，
所以依然以工具规则为粒度进行评估。

\subsection{路径敏感程度边界}

本文在在章节\ref{sec:\tc~静态分析工具及其原理}中提到，
路径敏感是工具检测过程的一种。
路径敏感程度是一种和语义建模深度正交的维度。
语义建模深度表征的是工具用了什么样的模型，
是一种表达能力；
而路径敏感则表征工具如何使用这个模型，
是否区分不同执行路径，
是一种分析精度策略。
为此，路径敏感程度和语义建模深度维度是正交的。
正交不意味着在该二维矩阵中的每个位置都一定存在场景，
也不意味着这两个维度的数据是无相关性的，
只是意味着这两个维度表征的是不同的能力。

本文将路径敏感程度维度的刻度设置如下。

\begin{enumerate}
	\item 路径不敏感。
	      这个刻度下的工具规则不能区分任何路径。

	\item 分支敏感。
	      这个刻度下的工具规则可以在遇到if/else语句的时候区分路径。

	\item 循环敏感。
	      这个刻度下的工具规则可以在遇到for/while循环的边界、
	      break/continue等分支时区分路径。

	\item 几乎完整的路径敏感。
	      除了若干深层路径，
	      这个刻度下的工具规则可以探知程序的大部分执行路径。
	      由于基于路径敏感分析的极高代价，
	      对静态分析工具来说，
	      在实践工程中面对大规模程序，
	      几乎完整的路径敏感是比较现实的考虑。

	\item 完整的路径敏感。
	      相比与前一个刻度，
	      这个刻度下的工具规则可以探知程序的每个可能执行路径，
	      但这只在理论上存在，
	      实际的工具不可能达到这个刻度。
\end{enumerate}

\subsection{路径状态空间控制能力边界}

路径爆炸是基于路径和状态的静态分析工具都需要面对的。
程序复杂度提高时，
路径数量并不是线性增长，
而是呈指数级增多，
并且在遇到循环等结构时，
路径数有可能是无限的，
故称为路径爆炸。
对路径状态空间的控制是静态分析工具的重要能力，
所评估工具能不能抑制路径爆炸？
能不能分析的了复杂路径？
为此，本文将路径状态空间控制能力作为一个边界。

控制路径爆炸的能力和语义建模深度、路径敏感程度都是正交的，
首先，这个维度的能力不管有没有，
都不影响前面介绍的两种能力。
虽然路径抑制能力的前提是有对路径敏感，
但这只会带来一个类似上三角矩阵的场景空间，
不影响能力的正交。

本文为该边界设置如下标志刻度。

\begin{enumerate}
	\item 无抑制。
	      该刻度下的工具规则没有任何抑制路径爆炸的手段。

	\item 主动合并状态。
	      这个刻度下的工具规则可以主动合并分支，
	      举例来说，
	      对于if和else分支的程序段逻辑完全相同，
	      上一个刻度的工具也许会分为两个路径分析，
	      但本刻度下的工具会将其作为一个路径分析，
	      这样一来就抑制了路径的倍数，
	      如果内层路径数量本身就很多，
	      那么两倍的分析量也足以让工具负担不起。

	\item 限制路径深度。
	      面对有可能无限增长的路径和状态，
	      静态分析工具需要有工程兜底能力，
	      是否设置了路径深度的上限。
	      在这个刻度下也有一个子维度，
	      即面对在非平凡循环时的展开限制。
	      正如在\ref{sec:\tc~静态分析工具及其原理}中提到，
	      MLN是一个工具在面对循环时展开的层数，
	      值一般不会超过5,
	      即工具会将循环展开MLN层进行分析，
	      如果程序在大于MLN层中有非平凡表现，
	      则工具识别不到，
	      如算法\ref{algo:非平凡循环}所示，
	      MLN值大于5与小于5的工具对其分析结果是不同的。
	      该参数是路径敏感的工具一定会有的，
	      否则很容易遇到无限路径的情况，
	      对于超过MLN的循环部分，
	      要么截断，
	      要么使用下文的widen技术。
	      为此，限制路径深度，
	      是工具规则在路径状态空间控制能力边界中的重要刻度。
	      \begin{algorithm}
		      \SetAlgoLined
		      $x \leftarrow 0$\;
		      \While{cond}{
			      $x \leftarrow x + 1$\;
		      }
		      \If{$x > 5$}{
			      bug()\;
		      }
		      \caption{非平凡循环}
		      \label{algo:非平凡循环}
	      \end{algorithm}

	\item 启用widen。
	      widen 是抽象解释中的一种状态加速技术，
	      用于在循环或递归分析中，
	      通过引入更粗粒度的抽象状态，
	      使状态序列在有限步内收敛，
	      从而保证分析终止。
	      典型的应用场景是单调的循环中，
	      使用末端的循环子去概括程序状态，
	      如算法\ref{algo:单调循环}所示，
	      无 widen 能力的工具会面对路径、状态爆炸，
	      而有 widen 能力的工具会使用i >= 0分析快速收敛。
	      widen技术是目前静态分析工具在路径空间控制中比较前沿的技术，
	      是否能利用widen是一个重要的能力刻度。
	      值得一提的是，
	      路径数量控制并没有一个完美的能力刻度。
	      \begin{algorithm}
		      \SetAlgoLined
		      $i \leftarrow 0$\;
		      \While{$i < 1000$}{
			      $i \leftarrow i + 1$\;
		      }
		      use($i$)\;
		      \caption{单调循环}
		      \label{algo:单调循环}
	      \end{algorithm}
\end{enumerate}

\subsection{约束精化能力}

约束精化指的是在静态分析过程中，
通过引入或加强路径约束，
判断某条分析得到的错误路径在真实程序中是否可达，
从而消除不可达路径导致的误报。
在程序的路径中，
有的路径是语法上可达，
但是语义上不可达的。
例如，

\begin{algorithm}
	\SetAlgoLined
	\If{x > 10}{
		\If{x < 5}{
			bug();
		}
	}
	\caption{语法可达但语义不可达}
	\label{algo:algorithm1}
\end{algorithm}

在分析过程中要对这条路径进行处理时，
如果有约束精化，
则不必付出太大代价去计算，
也不会发出很多误报；
如果没有则反之。
这个维度涉及到非常多的精化策略，
为简化能力边界的建模，
考虑到评估系统的复杂度和可验证性，
本文将约束精化能力的刻度设置为有和没有，
在实验章节进行是和否的验证。

\subsection{并发语义建模能力}

并发导致的问题在大型程序中非常常见，
这也是静态分析工具难以处理的点。
这个维度的能力涉及到线程间执行交错、
线程之间共享状态、
同步原语这三个本质问题的建模能力，
并不是一般意义上对结构的建模就可以处理的。

在这个维度下的刻度可以设置为：
不支持并发（单线程假设）、
线程感知（识别线程边界）、
同步感知（理解锁/原子）、
交错建模（分析线程交错），
但考虑到该维度能力的系统可验证性，
仅做抽象建模，
不做实验验证。

总结本节，
本文将静态分析工具的能力边界分为以下维度。

\begin{enumerate}
	\item 规则所对应的缺陷范围。
	\item 规则所能检查的工程作用域。
	\item 语义建模深度。
	\item 路径敏感程度。
	\item 路径状态空间控制程度。
	\item 约束精化能力。
	\item 并发语义建模能力。
\end{enumerate}

其中前两个维度是工具所能分析的范围，
后面的维度是工具理解程序的能力范围，
本文对每个维度都设置了对应的能力刻度，
并且维度之间相互正交，
任何一个工具都一定有这七个维度的能力边界，
本文的评估系统设计正是从这些能力边界出发，
尝试以场景为基础，
评估工具在不同能力边界维度上的表现。


\section{场景空间驱动的评估方法}
% 场景要诱导静态分析工具错误理解。

\subsection{场景空间}
为了系统化刻画影响静态分析工具检测能力的因素，
本文引入场景空间的概念如(\ref{eq:场景空间})

定义场景空间
\begin{equation}
	\mathcal{S} = \langle D, P, S, C, L, R \rangle
	\laber{eq:场景空间}
\end{equation}

其中的维度对应着章节\ref{sec:静态分析工具的能力边界}中的能力：

\begin{itemize}
	\item $D$ (Defect Set)：缺陷集。
	      对应规则所对应的缺陷范围，
	      该维度的不同场景有着不同的缺陷内容。
	\item $P$ (Program Span)：程序跨度。
	      对应规则所能检查的工程作用域，
	      该维度的不同场景拥有不同的程序跨度。
	\item $S$ (Semantic Complexity)：语义建模复杂度。
	      对应能力边界中的语义建模深度，
	      该维度的不同场景需要不同的语义建模能力。
	\item $C$ (Path Complexity)：路径复杂度。
	      对应能力边界中的路径敏感程度。
	      该维度的不同场景拥有不同的路径结构，
	      尝试考验工具规则的对不同结构的路径的识别能力。
	\item $L$ (Path Depth)：路径深度。
	      对应能力边界中的路径状态空间控制程度。
	      该维度的不同场景拥有不同的路径深度和复杂度，
	      尝试考验工具规则的路径爆炸控制能力。
	\item $R$ (Reachability)：有无不可达路径。
	      对应能力边界中的约束精化能力。
	      该维度的不同场景都有着不可达路径，
	      基于对该维度场景的检测结果，
	      可以评估工具规则是否有约束精化能力。
\end{itemize}

在该场景空间并不像数学的空间那样连续且有序，
而是在设计好的刻度下有着不同的位置。
例如这样的一个场景测例：

todo



\subsection{场景空间拓展方法}

目前主要的一些补充用例的方向可以分为两类，正向梳理和被动补充，如图\ref{fig:测试集拓展方式}。

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{测试集拓展方式.png}
	\caption{拓展测试集的两类方式}
	\label{fig:测试集拓展方式}
\end{figure}

正向梳理指的是基于现有测试集和代码的特征等已有知识，
通过调整结构、变化传递方式等正向手段增加测试用例，
相当于在一个多维的世界中进行深度搜索，
加上适当的剪支和限定，
可以实现构建一个接近“全覆盖”的场景测试集。

另一方面，被动补充方法指的是从实际触发的软件缺陷中，
提取相应的缺陷场景和正确场景。
这需要从缺陷管理系统（JIRA、GitHub 等）
和信息披露系统收集开源软件的缺陷信息，
进行爬取和复杂的数据整理。
这可以让缺陷更加适应实际软件缺陷，
让静态分析工具的评估更接近真实的应用场景。


\subsection{基于场景空间的测试结果解析}



\section{场景空间驱动的评估方法的优势与局限}
场景驱动评估并非替代传统测试集方法，而是提供了一种从能力视角审视评估问题的补充路径。